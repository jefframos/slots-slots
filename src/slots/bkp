import * as PIXI from 'pixi.js';

const SYMBOL_TEXTURES = [
    'symbol1.png',
    'symbol2.png',
    'symbol3.png',
    'symbol4.png',
    'symbol5.png',
];

const SPIN_SPEED = 50; // Pixels per frame
const SLOWDOWN_RATE = 0.95; // Rate at which the reel slows down

export class Reel {
    public container: PIXI.Container;
    private symbols: PIXI.Sprite[];
    private symbolSize: number;
    private symbolCount: number;
    private speed: number = 0;
    private isSpinning: boolean = false;

    constructor(symbolCount: number, symbolSize: number) {
        this.container = new PIXI.Container();
        this.symbols = [];
        this.symbolSize = symbolSize;
        this.symbolCount = symbolCount;

        this.createSymbols();
    }

    private createSymbols(): void {
        // Create symbols for the reel, arranged horizontally
    }

    private createRandomSymbol(): PIXI.Sprite {
        // TODO:Get a random symbol texture

        // TODO:Create a sprite with the texture

        return new PIXI.Sprite();
    }

    public update(delta: number): void {
        if (!this.isSpinning && this.speed === 0) return;

        // TODO:Move symbols horizontally

        // If we're stopping, slow down the reel
        if (!this.isSpinning && this.speed > 0) {
            this.speed *= SLOWDOWN_RATE;

            // If speed is very low, stop completely and snap to grid
            if (this.speed < 0.5) {
                this.speed = 0;
                this.snapToGrid();
            }
        }
    }

    private snapToGrid(): void {
        // TODO: Snap symbols to horizontal grid positions

    }

    public startSpin(): void {
        this.isSpinning = true;
        this.speed = SPIN_SPEED;
    }

    public stopSpin(): void {
        this.isSpinning = false;
        // The reel will gradually slow down in the update method
    }
}












import 'pixi-spine';
import { AssetLoader } from '../utils/AssetLoader';
import PromiseUtils from '../utils/PromiseUtils';
import { sound } from '../utils/SoundHandler';
import { SpineAnimationHandler } from '../utils/SpineAnimationHandler';
import { Reel } from './Reel2';

const REEL_COUNT = 4;
const SYMBOLS_PER_REEL = 6;
const SYMBOL_SIZE = 150;
const REEL_HEIGHT = SYMBOL_SIZE;
const REEL_SPACING = 10;

export class SlotMachine {
    public container: PIXI.Container;
    private reels: Reel[];
    private app: PIXI.Application;
    private isSpinning: boolean = false;
    private spinButton: PIXI.Sprite | null = null;
    private frameSpine!: SpineAnimationHandler;
    private winAnimation!: SpineAnimationHandler;

    constructor(app: PIXI.Application) {
        this.app = app;
        this.container = new PIXI.Container();
        this.reels = [];

        // Center the slot machine
        this.container.x = this.app.screen.width / 2 - ((SYMBOL_SIZE * SYMBOLS_PER_REEL) / 2);
        this.container.y = this.app.screen.height / 2 - ((REEL_HEIGHT * REEL_COUNT + REEL_SPACING * (REEL_COUNT - 1)) / 2);

        this.createBackground();

        this.createReels();

        this.initSpineAnimations();
    }

    private createBackground(): void {
        try {
            const background = new PIXI.Graphics();
            background.beginFill(0x000000, 0.5);
            background.drawRect(
                -20,
                -20,
                SYMBOL_SIZE * SYMBOLS_PER_REEL + 40, // Width now based on symbols per reel
                REEL_HEIGHT * REEL_COUNT + REEL_SPACING * (REEL_COUNT - 1) + 40 // Height based on reel count
            );
            background.endFill();
            this.container.addChild(background);
        } catch (error) {
            console.error('Error creating background:', error);
        }
    }

    private createReels(): void {
        // Create each reel


        for (let i = 0; i < REEL_COUNT; i++) {
            const reel = new Reel(SYMBOLS_PER_REEL, SYMBOL_SIZE);
            reel.container.y = i * (REEL_HEIGHT + REEL_SPACING);
            this.container.addChild(reel.container);
            this.reels.push(reel);
        }
    }

    public update(delta: number): void {
        // Update each reel
        for (const reel of this.reels) {
            reel.update(delta);
        }
    }

    public async spin(): Promise<void> {
        if (this.isSpinning) return;

        this.isSpinning = true;

        // Play spin sound
        sound.play('Reel spin');

        // Disable spin button
        if (this.spinButton) {
            this.spinButton.texture = AssetLoader.getTexture('button_spin_disabled.png');
            this.spinButton.interactive = false;
        }

        // Start spinning each reel with delay
        for (let i = 0; i < this.reels.length; i++) {
            await PromiseUtils.delay(i * 200);
            this.reels[i].startSpin();
        }

        // Wait before stopping the reels
        const totalSpinDelay = 500 + (this.reels.length - 1) * 200;
        await PromiseUtils.delay(totalSpinDelay);

        await this.stopSpin(); // now also async
    }

    private async stopSpin(): Promise<void> {
        for (let i = 0; i < this.reels.length; i++) {
            await PromiseUtils.delay(i * 400); // stagger each reel's stop
            this.reels[i].stopSpin();
        }

        await PromiseUtils.delay(500); // wait after last reel stops

        this.checkWin();
        this.isSpinning = false;

        if (this.spinButton) {
            this.spinButton.texture = AssetLoader.getTexture('button_spin.png');
            this.spinButton.interactive = true;
        }
    }

    private checkWin(): void {
        // Simple win check - just for demonstration
        const randomWin = Math.random() < 0.3; // 30% chance of winning

        if (randomWin) {
            sound.play('win');
            console.log('Winner!');

            if (this.winAnimation) {
                this.winAnimation.spine.visible = true;
                this.winAnimation.playAnimation('start').then(() => {
                    this.winAnimation.spine.visible = false;
                })
                // TODO: Play the win animation found in "big-boom-h" spine
            }
        }
    }

    public setSpinButton(button: PIXI.Sprite): void {
        this.spinButton = button;
    }

    private initSpineAnimations(): void {
        try {
            this.frameSpine = new SpineAnimationHandler('base-feature-frame.json');
            this.frameSpine.load().then(() => {
                this.frameSpine.spine.visible = true;
                this.frameSpine.spine.y = (REEL_HEIGHT * REEL_COUNT + REEL_SPACING * (REEL_COUNT - 1)) / 2;
                this.frameSpine.spine.x = (SYMBOL_SIZE * SYMBOLS_PER_REEL) / 2;
                this.container.addChild(this.frameSpine.spine);
                this.frameSpine.playAnimation('idle', true);
            });


            this.winAnimation = new SpineAnimationHandler('big-boom-h.json');
            this.winAnimation.load().then(() => {
                this.winAnimation.spine.visible = false;
                this.winAnimation.spine.x = (REEL_HEIGHT * REEL_COUNT + REEL_SPACING * (REEL_COUNT - 1)) / 2;
                this.winAnimation.spine.y = (SYMBOL_SIZE * SYMBOLS_PER_REEL) / 2;
                this.container.addChild(this.winAnimation.spine);
            })

        } catch (error) {
            console.error('Error initializing spine animations:', error);
        }
    }
}
